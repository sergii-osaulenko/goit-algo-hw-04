# goit-algo-hw-04
Homework #4

# Порівняння алгоритмів сортування: вставками, злиттям та Timsort

У роботі порівнюються три алгоритми сортування: сортування вставками, сортування злиттям та вбудований у Python алгоритм Timsort (функції `sorted` та метод `list.sort`). Метою є емпірична перевірка теоретичної складності цих алгоритмів та демонстрація переваг гібридного підходу Timsort.

## Методика експерименту

Було реалізовано власні версії сортування вставками та сортування злиттям, а Timsort використовувався через вбудовану функцію `sorted`. Для вимірювання часу виконання застосовано модуль `timeit`, кожен алгоритм запускався по 5 разів на одному й тому самому вхідному масиві, а середній час записувався до таблиці результатів (`sorting_benchmark.csv`).

Тестування проводилось на масивах розмірів 100, 1000 та 5000 елементів чотирьох типів: випадкові дані, вже відсортовані, відсортовані у зворотному порядку та майже відсортовані послідовності.

## Таблиця результатів (випадкові дані)

Нижче наведено час виконання трьох алгоритмів сортування на випадкових масивах різного розміру. Час виміряно модулем `timeit` як сумарний час 5 запусків кожного алгоритму на однаковому вхідному масиві.

| Тип даних | n    | Алгоритм  | Час (секунд, 5 запусків) |
|-----------|------|-----------|--------------------------|
| random    | 100  | insertion | 0.0017810999997891486    |
| random    | 100  | merge     | 0.0011639000149443746    |
| random    | 100  | timsort   | 4.9600028432905674e-05   |
| random    | 1000 | insertion | 0.09890219999942929      |
| random    | 1000 | merge     | 0.0065953999874182045    |
| random    | 1000 | timsort   | 0.0003643999807536602    |
| random    | 5000 | insertion | 4.563317000051029        |
| random    | 5000 | merge     | 0.06105109996860847      |
| random    | 5000 | timsort   | 0.004209500038996339     |

## Результати та емпірична перевірка складності

Отримані результати показали, що час роботи сортування вставками зростає квадратично з розміром вхідних даних, що відповідає теоретичній оцінці складності \(O(n^2)\). На масивах розміру 5000 цей алгоритм демонструє суттєво більший час виконання порівняно з іншими методами.

Сортування злиттям та Timsort показали зростання часу, наближене до \(O(n \log n)\). Для однакових розмірів масивів обидва ці алгоритми значно швидші за сортування вставками, особливо на великих вибірках.

## Переваги Timsort

Timsort поєднує ідеї сортування злиттям та сортування вставками. На практиці це означає, що алгоритм:

- **Розбиває** послідовність на вже відсортовані підпослідовності (runs) і ефективно їх об’єднує, подібно до сортування злиттям.
- Використовує сортування вставками для коротких фрагментів, де цей алгоритм працює дуже швидко на майже відсортованих даних.

У результаті Timsort виявився найшвидшим алгоритмом у всіх проведених експериментах, особливо на вже відсортованих та майже відсортованих масивах, де він суттєво випереджає як сортування вставками, так і класичне сортування злиттям.

## Висновки

1. Емпіричні дані підтвердили теоретичні оцінки: сортування вставками має квадратичну складність і стає неефективним на великих наборах, тоді як сортування злиттям і Timsort демонструють \(O(n \log n)\) поведінку.
2. Гібридний алгоритм Timsort, який поєднує сильні сторони сортування злиттям та сортування вставками і додатково враховує вже існуючу впорядкованість даних, показав найкращі результати на всіх типах протестованих наборів.
3. Отримані результати пояснюють, чому на практиці програмісти переважно користуються вбудованими алгоритмами сортування (такими як Timsort у Python), а не реалізують власні сортери з нуля, за винятком спеціалізованих випадків.